from __future__ import absolute_import
import numpy as np
from datetime import datetime

from lmatools.io.LMA_h5_file import LMAh5Collection
from lmatools.grid.make_grids import time_edges, seconds_since_start_of_day
from lmatools.grid.density_to_files import ArrayChopper, stack_chopped_arrays

class TimeSeriesGenericFlashSubset(object):
    """ This class is not meant to be used alone. A subclass which provides
        self.lma corresponding to the LMAh5Collection API is necessary.
    """
    def __init__(self, t_start, t_end, dt, base_date=None):
        self.lma = None
        
        if base_date is None:
            self.base_date = datetime(t_start.year, t_start.month, t_start.day)
        else: 
            self.base_date = base_date
        
        t_edges, duration = time_edges(t_start, t_end, dt.total_seconds())
        self.t_edges = t_edges
        self.basedate, t_edges_seconds = seconds_since_start_of_day(t_start, t_edges)
        self.t_edges_seconds = np.asarray(t_edges_seconds)
        self.n_frames = len(t_edges)-1
        
        self.t_chopper = ArrayChopper(t_edges_seconds)
        
    def t_edges_to_isoformat(self, as_start_end=False):
        """ Return a list of ISO formatted time strings.
        
            If as_start_end=True, return (iso_start, iso_end)
            corresponding to the left and right edges of each window
        """
        iso = [t.isoformat() for t in self.t_edges]
        if as_start_end == True:
            return iso[:-1], iso[1:]
        else:
            return iso
        
    def gen_chopped_events_flashes(self):
        """ For each file in h5_filenames, generate a sequence of (events, flashes)
            which have been chopped apart into the individual time series windows.
            
            Because data files might cross time windows (for instance, a time
            series with two minute spacing on odd minutes, which would cross 
            a day boundary), the consumer of these events and flashes must wait
            to consume all data from the generator before being certain that 
            all events and flashes for a certain time window are available. 
            An example of consuming and stacking up all data is 
            in self.get_event_flash_time_series.
            
        """

        for events, flashes in self.lma:
            # Get a list of subarrays corresponding to the time windows given
            # by self.t_edges
            chopped_events = self.t_chopper.chop(events, edge_key='time')
            chopped_flashes = self.t_chopper.chop(flashes, edge_key='start')
            ev_lens = [e.shape for e in chopped_events]
            fl_lens = [f.shape for f in chopped_flashes]
            yield chopped_events, chopped_flashes
    
    def get_event_flash_time_series(self):
        """ Return two lists: events, flashes
            Each list has N arrays corresponding to N+1 self.t_edges
        """
        events = []
        flashes = []
        # This loops over chunks of data generated by the h5 file reader, not
        # the time series windows.
        for ev_chop, fl_chop in self.gen_chopped_events_flashes():
            events.append(ev_chop)
            flashes.append(fl_chop)
        return stack_chopped_arrays(events), stack_chopped_arrays(flashes)

class TimeSeriesFlashSubset(TimeSeriesGenericFlashSubset):
    def __init__(self, h5_filenames, t_start, t_end, dt, base_date=None, min_points=10):
        """ 
            t_start, t_end: datetime objects giving start and end of the time series
            dt: datetime.timedelta object giving the time series interval
        
            h5_filenames are in the lmatools format.
            
            Attributes
            t_edges: edges of the time series windows as datetime objects
            n_frames: number of time series windows
        """
        super(TimeSeriesFlashSubset, self).__init__(t_start, t_end, dt, base_date=None)
        self.lma = LMAh5Collection(h5_filenames, min_points=min_points, base_date=self.base_date)
        

        
class TimeSeriesPolygonFlashSubset(TimeSeriesFlashSubset):
    def __init__(self, *args, **kwargs):
        # could also accept coord_names and time_key kwargs here, but those
        # should be standardized in the lmatools h5 format, so we hard code
        # them below
        
        # This is here because the PolygonLassoFilter imports matplotlib
        # and we don't want other imports from this module that don't
        # need matplotlib to trigger a matplotlib import
        from lmatools.lasso.energy_stats import TimeSeriesPolygonLassoFilter 
        
        self.polys = kwargs.pop('polys', [])
        self.t_edges_polys = kwargs.pop('t_edges_polys', [])

        super(TimeSeriesPolygonFlashSubset, self).__init__(*args, **kwargs)
        
        # strictly speaking, we don't even need the time series part; that's been done
        # and we're just lassoin' the points. 
        # But, this code is known to work, so we just reuse it here.
        self.fl_lassos = TimeSeriesPolygonLassoFilter(coord_names=('init_lon', 'init_lat'), time_key='start',
                                         time_edges=self.t_edges_polys, polys=self.polys, basedate=self.base_date )
        self.ev_lassos = TimeSeriesPolygonLassoFilter(coord_names=('lon', 'lat'), time_key='time',
                                         time_edges=self.t_edges_polys, polys=self.polys, basedate=self.base_date)
        self.grid_lassos = TimeSeriesPolygonLassoFilter(coord_names=('lon', 'lat'), time_key='t',
                                         time_edges=self.t_edges_polys, polys=self.polys, basedate=self.base_date)
    
    def gen_chopped_events_flashes(self, *args, **kwargs):
        parent = super(TimeSeriesPolygonFlashSubset, self)
        for ch_ev_series, ch_fl_series in parent.gen_chopped_events_flashes(*args, **kwargs):
            # This gives a time series for each HDF5 LMA file. Next loop
            # over each chopped time series window.
            # Apply polygon filter to time series created by superclass, yield chopped events and flashes
            lassoed_ev = [ch_ev[self.ev_lassos.filter_mask(ch_ev)] for ch_ev in ch_ev_series]
            lassoed_fl = [ch_fl[self.fl_lassos.filter_mask(ch_fl)] for ch_fl in ch_fl_series]
            yield lassoed_ev, lassoed_fl
            